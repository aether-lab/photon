# Autogenerated with SMOP version 
# /Users/lalit/anaconda/bin/smop perform_ray_tracing_03.m

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def perform_ray_tracing_03_(piv_simulation_parameters=None,optical_system=None,pixel_gain=None,scattering_data=None,scattering_type=None,lightfield_source=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[piv_simulation_parameters,optical_system,pixel_gain,scattering_data,scattering_type,lightfield_source].count(None)+len(args)

    object_distance=piv_simulation_parameters.lens_design.object_distance
    focal_length=piv_simulation_parameters.lens_design.focal_length
    aperture_f_number=piv_simulation_parameters.lens_design.aperture_f_number
    x_pixel_number=piv_simulation_parameters.camera_design.x_pixel_number
    y_pixel_number=piv_simulation_parameters.camera_design.y_pixel_number
    pixel_bit_depth=piv_simulation_parameters.camera_design.pixel_bit_depth
    beam_wavelength=piv_simulation_parameters.particle_field.beam_wavelength
    refractive_index=optical_system.design.optical_element.optical_element.element_properties.refractive_index
    front_surface_radius=optical_system.design.optical_element.optical_element.element_geometry.front_surface_radius
    optical_system_length=optical_system.design.optical_element.optical_element.element_geometry.vertex_distance
    lightray_number_per_particle=lightfield_source.lightray_number_per_particle
    lightray_process_number=lightfield_source.lightray_process_number
    image_distance=(1 / focal_length - 1 / object_distance) ** - 1
    h2_principal_plane=- (focal_length * (refractive_index - 1) * optical_system_length) / (front_surface_radius * refractive_index)
    v2_vertex_plane=image_distance + h2_principal_plane
    v1_vertex_plane=v2_vertex_plane + optical_system_length
    z_sensor=0
    z_lens=(v1_vertex_plane + v2_vertex_plane) / 2
    lens_pitch=focal_length / aperture_f_number
    elements_coplanar=matlabarray([])
    element_type=matlabarray([])
    element_count=0
    element_data=cell_(1,1)
    element_center,__,element_plane_parameters,__,__,__,element_system_index,__,element_data=create_element_coordinate_arrays_(optical_system.design,elements_coplanar,element_type,element_count,element_data,nargout=9)
    element_plane_parameters[:,4]=element_plane_parameters[:,4] - element_plane_parameters[:,3] * (z_lens)
    element_center[:,3]=element_center[:,3] + (z_lens)
    I=zeros_(x_pixel_number,y_pixel_number)
    lightfield_vector=arange_(1,length_(lightfield_source.x),ceil_(lightray_process_number / lightray_number_per_particle))
    if lightfield_vector[end()] != length_(lightfield_source.x):
        lightfield_vector=matlabarray([lightfield_vector,length_(lightfield_source.x)])
    for m in arange_(1,(length_(lightfield_vector) - 1)).reshape(-1):
        display_calculation_progress_(m,(arange_(1,length_(lightfield_vector) - 1)))
        lightfield_data=generate_lightfield_angular_data_(lens_pitch,image_distance,scattering_data,scattering_type,lightfield_source,lightray_number_per_particle,lightfield_vector[m],lightfield_vector[m + 1])
        light_ray_data.ray_source_coordinates=[lightfield_data.x.T,lightfield_data.y.T,lightfield_data.z.T]
        light_ray_data.ray_propogation_direction=[lightfield_data.theta.T,lightfield_data.phi.T,- ones_(size_(lightfield_data.theta)).T]
        light_ray_data.ray_propogation_direction=bsxfun_(rdivide,light_ray_data.ray_propogation_direction,sqrt_(light_ray_data.ray_propogation_direction(arange_(),1) ** 2 + light_ray_data.ray_propogation_direction(arange_(),2) ** 2 + light_ray_data.ray_propogation_direction(arange_(),3) ** 2))
        light_ray_data.ray_wavelength=beam_wavelength * ones_(size_(lightfield_data.theta)).T
        light_ray_data.ray_radiance=(1 / aperture_f_number ** 2) * lightfield_data.radiance.T
        light_ray_data=propogate_rays_through_optical_system_(element_data,element_center,element_plane_parameters,element_system_index,light_ray_data)
        ray_propogation_direction=light_ray_data.ray_propogation_direction
        ray_source_coordinates=light_ray_data.ray_source_coordinates
        a=0
        b=0
        c=1
        d=- z_sensor
        intersection_time=- (a * ray_source_coordinates[:,1] + b * ray_source_coordinates[:,2] + c * ray_source_coordinates[:,3] + d) / (a * ray_propogation_direction[:,1] + b * ray_propogation_direction[:,2] + c * ray_propogation_direction[:,3])
        x_intersect=ray_source_coordinates[:,1] + ray_propogation_direction[:,1].dot(intersection_time)
        y_intersect=ray_source_coordinates[:,2] + ray_propogation_direction[:,2].dot(intersection_time)
        z_intersect=ray_source_coordinates[:,3] + ray_propogation_direction[:,3].dot(intersection_time)
        ray_source_coordinates=matlabarray([x_intersect,y_intersect,z_intersect])
        alpha=atan_(sqrt_((ray_propogation_direction[:,1] / ray_propogation_direction[:,3]) ** 2 + (ray_propogation_direction[:,2] / ray_propogation_direction[:,3]) ** 2))
        cos_4_alpha=cos_(alpha) ** 4
        ii_indices,jj_indices,pixel_weights=intersect_sensor_better_(piv_simulation_parameters.camera_design,ray_source_coordinates[:,1].T,ray_source_coordinates[:,2].T,nargout=3)
        for n in arange_(1,size_(ray_source_coordinates,1)).reshape(-1):
            for p in arange_(1,4).reshape(-1):
                if not_(isnan_(pixel_weights[n,p])):
                    I[ii_indices[n,p],jj_indices[n,p]]=I[ii_indices[n,p],jj_indices[n,p]] + pixel_weights[n,p] * light_ray_data.ray_radiance(n) * cos_4_alpha[n]
    I=I * 10 ** (pixel_gain / 20)
    I=(2 ** pixel_bit_depth - 1) * I / (2 ** 16 - 1)
    I=round_(I)
    I=I * (2 ** 16 - 1) / (2 ** pixel_bit_depth - 1)
    I=uint16_(I)
    return I
def create_element_coordinate_arrays_(optical_element=None,elements_coplanar=None,element_type=None,element_count=None,element_data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[optical_element,elements_coplanar,element_type,element_count,element_data].count(None)+len(args)

    element_number=optical_element.element_number
    element_center=matlabarray([])
    element_pitch=matlabarray([])
    element_plane_parameters=matlabarray([])
    element_thickness=matlabarray([])
    element_system_index=matlabarray([])
    element_system_index_temp=1
    total_element_distance=0
    system_distance=0
    for element_index in arange_(1,element_number).reshape(-1):
        current_optical_element=optical_element.optical_element(element_index)
        current_element_type=current_optical_element.element_type
        if strcmp_(current_element_type,char('system')):
            elements_coplanar=current_optical_element.elements_coplanar
            z_inter_element_distance=current_optical_element.z_inter_element_distance
            axial_offset_distances=current_optical_element.axial_offset_distances
            rotation_angles=current_optical_element.rotation_angles
            x_rotation_angle=rotation_angles[1]
            y_rotation_angle=rotation_angles[2]
            z_rotation_angle=rotation_angles[3]
            x_rotation_matrix=matlabarray([[1,0,0],[0,cos_(x_rotation_angle),sin_(x_rotation_angle)],[0,- sin_(x_rotation_angle),cos_(x_rotation_angle)]])
            y_rotation_matrix=matlabarray([[cos_(y_rotation_angle),0,- sin_(y_rotation_angle)],[0,1,0],[sin_(y_rotation_angle),0,cos_(y_rotation_angle)]])
            z_rotation_matrix=matlabarray([[cos_(z_rotation_angle),sin_(z_rotation_angle),0],[- sin_(z_rotation_angle),cos_(z_rotation_angle),0],[0,0,1]])
            rotation_matrix=x_rotation_matrix * y_rotation_matrix * z_rotation_matrix
            element_center_temp,element_pitch_temp,element_plane_parameters_temp,element_type,element_thickness_temp,total_element_distance_temp,element_system_index_temp,element_count,element_data=create_element_coordinate_arrays_(current_optical_element,elements_coplanar,element_type,element_count,element_data,nargout=9)
            x0=0
            y0=0
            z0=total_element_distance_temp / 2
            rotation_origin=matlabarray([[x0],[y0],[z0]])
            for element_temp_index in arange_(1,size_(element_center_temp,1)).reshape(-1):
                x0=element_center_temp[element_temp_index,1]
                y0=element_center_temp[element_temp_index,2]
                z0=element_center_temp[element_temp_index,3]
                R=element_pitch_temp[element_temp_index]
                a=element_plane_parameters_temp[element_temp_index,1]
                b=element_plane_parameters_temp[element_temp_index,2]
                c=element_plane_parameters_temp[element_temp_index,3]
                d=element_plane_parameters_temp[element_temp_index,4]
                xp=0
                yp=0
                zp=- d / c
                plane_normal=matlabarray([[a],[b],[c]])
                plane_normal=(rotation_matrix) * plane_normal
                a_temp=plane_normal[1]
                b_temp=plane_normal[2]
                c_temp=plane_normal[3]
                plane_point=matlabarray([[xp],[yp],[zp]])
                plane_point=rotation_matrix * (plane_point - rotation_origin) + rotation_origin
                xp=plane_point[1]
                yp=plane_point[2]
                zp=plane_point[3]
                d_temp=- (a_temp * xp + b_temp * yp + c_temp * zp)
                element_center_temp[element_temp_index,:]=(rotation_matrix * (element_center_temp[element_temp_index,:].T - rotation_origin) + rotation_origin).T
                element_center_temp[element_temp_index,1]=element_center_temp[element_temp_index,1] + axial_offset_distances[1]
                element_center_temp[element_temp_index,2]=element_center_temp[element_temp_index,2] + axial_offset_distances[2]
                element_center_temp[element_temp_index,3]=element_center_temp[element_temp_index,3] + system_distance
                d_temp=d_temp - (a_temp * axial_offset_distances[1] + b_temp * axial_offset_distances[2] + c_temp * system_distance)
                element_plane_parameters_temp[element_temp_index,:]=[a_temp,b_temp,c_temp,d_temp]
            system_distance=system_distance + total_element_distance_temp + z_inter_element_distance
        else:
            vertex_distance=current_optical_element.element_geometry.vertex_distance
            z_inter_element_distance=current_optical_element.z_inter_element_distance
            element_center_temp,element_pitch_temp,element_plane_parameters_temp=create_single_element_parameters_(current_optical_element,nargout=3)
            element_center_temp[3]=element_center_temp[3] + total_element_distance
            element_plane_parameters_temp[4]=- element_plane_parameters_temp[3] * element_center_temp[3]
            if element_index < element_number:
                total_element_distance=total_element_distance + not_(elements_coplanar) * vertex_distance + z_inter_element_distance
            else:
                total_element_distance=total_element_distance + vertex_distance + z_inter_element_distance
            if isempty_(element_type):
                element_type[1,1]=current_element_type
            else:
                element_type[end() + 1,1]=current_element_type
            element_thickness_temp=copy_(vertex_distance)
            if not_(elements_coplanar):
                element_system_index_temp=element_system_index_temp + 1
            element_count=element_count + 1
            element_data[element_count,:]=current_optical_element
        element_center=matlabarray([[element_center],[element_center_temp]])
        element_pitch=matlabarray([[element_pitch],[element_pitch_temp]])
        element_plane_parameters=matlabarray([[element_plane_parameters],[element_plane_parameters_temp]])
        element_thickness=matlabarray([[element_thickness],[element_thickness_temp]])
        element_system_index=matlabarray([[element_system_index],[element_system_index_temp]])
    return element_center,element_pitch,element_plane_parameters,element_type,element_thickness,total_element_distance,element_system_index,element_count,element_data
def create_single_element_parameters_(optical_element=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[optical_element].count(None)+len(args)

    axial_offset_distances=optical_element.axial_offset_distances
    rotation_angles=optical_element.rotation_angles
    x_rotation_angle=rotation_angles[1]
    y_rotation_angle=rotation_angles[2]
    z_rotation_angle=rotation_angles[3]
    element_center,element_pitch,element_plane_parameters=create_element_coordinate_data_(optical_element,nargout=3)
    x_rotation_matrix=matlabarray([[1,0,0],[0,cos_(x_rotation_angle),sin_(x_rotation_angle)],[0,- sin_(x_rotation_angle),cos_(x_rotation_angle)]])
    y_rotation_matrix=matlabarray([[cos_(y_rotation_angle),0,- sin_(y_rotation_angle)],[0,1,0],[sin_(y_rotation_angle),0,cos_(y_rotation_angle)]])
    z_rotation_matrix=matlabarray([[cos_(z_rotation_angle),sin_(z_rotation_angle),0],[- sin_(z_rotation_angle),cos_(z_rotation_angle),0],[0,0,1]])
    rotation_matrix=x_rotation_matrix * y_rotation_matrix * z_rotation_matrix
    rotated_plane_parameters=rotation_matrix * (element_plane_parameters[1:3].T)
    element_plane_parameters[1:3]=rotated_plane_parameters.T
    element_center[1]=element_center[1] + axial_offset_distances[1]
    element_center[2]=element_center[2] + axial_offset_distances[2]
    element_plane_parameters=element_plane_parameters / norm_(element_plane_parameters[1:3])
    return element_center,element_pitch,element_plane_parameters
def create_element_coordinate_data_(optical_element=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[optical_element].count(None)+len(args)

    element_type=optical_element.element_type
    if not_(strcmp_(element_type,char('lens'))) and not_(strcmp_(element_type,char('aperture'))) and not_(strcmp_(element_type,char('mirror'))):
        error_(char("The optical element type is not 'lens', 'aperture', or 'mirror'."))
    pitch=optical_element.element_geometry.pitch
    x_element_center=0
    y_element_center=0
    z_element_center=0
    element_center=matlabarray([x_element_center,y_element_center,z_element_center])
    element_pitch=pitch / 2
    a_element_plane_parameter=0
    b_element_plane_parameter=0
    c_element_plane_parameter=1
    d_element_plane_parameter=0
    element_plane_parameters=matlabarray([a_element_plane_parameter,b_element_plane_parameter,c_element_plane_parameter,d_element_plane_parameter])
    return element_center,element_pitch,element_plane_parameters
def generate_lightfield_angular_data_(lens_pitch=None,image_distance=None,scattering_data=None,scattering_type=None,lightfield_source=None,lightray_number_per_particle=None,n_min=None,n_max=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 8-[lens_pitch,image_distance,scattering_data,scattering_type,lightfield_source,lightray_number_per_particle,n_min,n_max].count(None)+len(args)

    if strcmp_(scattering_type,char('mie')):
        mie_scattering_angle=scattering_data.scattering_angle
        mie_scattering_irradiance=scattering_data.scattering_irradiance
        inverse_rotation_matrix=scattering_data.inverse_rotation_matrix
        beam_propogation_vector=scattering_data.beam_propogation_vector
    source_point_number=n_max - n_min + 1
    lightfield_data=copy_(struct)
    lightfield_data.x=zeros_(1,source_point_number * lightray_number_per_particle)
    lightfield_data.y=zeros_(1,source_point_number * lightray_number_per_particle)
    lightfield_data.z=zeros_(1,source_point_number * lightray_number_per_particle)
    lightfield_data.theta=zeros_(1,source_point_number * lightray_number_per_particle)
    lightfield_data.phi=zeros_(1,source_point_number * lightray_number_per_particle)
    lightfield_data.radiance=zeros_(1,source_point_number * lightray_number_per_particle)
    R=lens_pitch / 2
    for n in arange_(n_min,n_max).reshape(-1):
        x_current=lightfield_source.x(n)
        y_current=lightfield_source.y(n)
        z_current=lightfield_source.z(n)
        r=R * sqrt_(rand_(1,lightray_number_per_particle))
        psi=2 * pi * rand_(1,lightray_number_per_particle)
        x_lens=r.dot(cos_(psi))
        y_lens=r.dot(sin_(psi))
        if strcmp_(scattering_type,char('mie')):
            diameter_index=lightfield_source.diameter_index(n)
            ray_direction_vector=matlabarray([[x_lens - x_current],[y_lens - y_current],[image_distance * ones_(1,lightray_number_per_particle) - z_current]])
            ray_direction_vector=bsxfun_(rdivide,ray_direction_vector,sqrt_(ray_direction_vector[1,:] ** 2 + ray_direction_vector[2,:] ** 2 + ray_direction_vector[3,:] ** 2))
            ray_direction_vector=inverse_rotation_matrix * ray_direction_vector
            ray_scattering_angles=acos_(beam_propogation_vector * ray_direction_vector)
            ray_scattering_irradiance=interp1_(mie_scattering_angle,mie_scattering_irradiance[:,diameter_index],ray_scattering_angles,char('linear'))
            irradiance_current=ray_scattering_irradiance * lightfield_source.radiance(n)
        else:
            if strcmp_(scattering_type,char('diffuse')):
                irradiance_current=lightfield_source.radiance(n)
        theta_temp=- (x_lens - x_current) / (image_distance - z_current)
        phi_temp=- (y_lens - y_current) / (image_distance - z_current)
        index_vector=arange_((n - n_min) * lightray_number_per_particle + 1,(n - n_min + 1) * lightray_number_per_particle)
        lightfield_data.x[index_vector]=x_current
        lightfield_data.y[index_vector]=y_current
        lightfield_data.z[index_vector]=z_current
        lightfield_data.theta[index_vector]=theta_temp
        lightfield_data.phi[index_vector]=phi_temp
        lightfield_data.radiance[index_vector]=irradiance_current
    return lightfield_data
def intersect_sensor_better_(camera_design=None,x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[camera_design,x,y].count(None)+len(args)

    pixel_pitch=camera_design.pixel_pitch
    x_pixel_number=camera_design.x_pixel_number
    y_pixel_number=camera_design.y_pixel_number
    pixel_1_x=- pixel_pitch * (x_pixel_number - 1) / 2
    pixel_1_y=- pixel_pitch * (y_pixel_number - 1) / 2
    d_x=(x.T - pixel_1_x) / pixel_pitch + 1.5
    d_y=(y.T - pixel_1_y) / pixel_pitch + 1.5
    d_y_lower=d_y - 0.5
    d_x_lower=d_x - 0.5
    d_ii_ul=ceil_(d_y_lower) - d_y_lower
    d_jj_ul=ceil_(d_x_lower) - d_x_lower
    w_ul=(d_ii_ul).dot((d_jj_ul))
    d_ii_ur=ceil_(d_y_lower) - d_y_lower
    d_jj_ur=1 - d_jj_ul
    w_ur=(d_ii_ur).dot((d_jj_ur))
    d_ii_ll=1 - d_ii_ul
    d_jj_ll=ceil_(d_x_lower) - d_x_lower
    w_ll=(d_ii_ll).dot((d_jj_ll))
    d_ii_lr=1 - d_ii_ul
    d_jj_lr=1 - d_jj_ul
    w_lr=(d_ii_lr).dot((d_jj_lr))
    ii_ul=ceil_(d_y_lower) - 1
    jj_ul=ceil_(d_x_lower) - 1
    ii_ur=ceil_(d_y_lower) - 1
    jj_ur=jj_ul + 1
    ii_ll=ii_ul + 1
    jj_ll=ceil_(d_x_lower) - 1
    ii_lr=ii_ul + 1
    jj_lr=jj_ul + 1
    ii_indices=matlabarray([ii_ul,ii_ur,ii_ll,ii_lr])
    jj_indices=matlabarray([jj_ul,jj_ur,jj_ll,jj_lr])
    pixel_weights=matlabarray([w_ul,w_ur,w_ll,w_lr])
    pixel_weights[(jj_indices < 1) or (x_pixel_number < jj_indices)]=NaN
    pixel_weights[(ii_indices < 1) or (y_pixel_number < ii_indices)]=NaN
    return ii_indices,jj_indices,pixel_weights
def propogate_rays_through_optical_system_(element_data=None,element_center=None,element_plane_parameters=None,element_system_index=None,light_ray_data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[element_data,element_center,element_plane_parameters,element_system_index,light_ray_data].count(None)+len(args)

    sequential_element_number=max_(element_system_index)
    element_system_index=sequential_element_number - element_system_index + 1
    for element_index in arange_(1,sequential_element_number).reshape(-1):
        current_element_indices=find_(element_system_index == element_index)
        simultaneous_element_number=length_(current_element_indices)
        if simultaneous_element_number == 1:
            current_optical_element=element_data[current_element_indices]
            current_plane_parameters=element_plane_parameters[current_element_indices,:]
            current_element_center=element_center[current_element_indices,:]
            light_ray_data=propogate_rays_through_single_element_(current_optical_element,current_element_center,current_plane_parameters,light_ray_data)
        else:
            current_optical_element=cell_(simultaneous_element_number,1)
            for simultaneous_element_index in arange_(1,simultaneous_element_number).reshape(-1):
                current_optical_element[simultaneous_element_index,:]=element_data[current_element_indices[simultaneous_element_index]]
            current_plane_parameters=element_plane_parameters[current_element_indices,:]
            current_element_center=element_center[current_element_indices,:]
            light_ray_data=propogate_rays_through_multiple_elements_(current_optical_element,current_element_center,current_plane_parameters,light_ray_data)
    return light_ray_data
def propogate_rays_through_multiple_elements_(optical_element=None,element_center=None,element_plane_parameters=None,light_ray_data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[optical_element,element_center,element_plane_parameters,light_ray_data].count(None)+len(args)

    ray_propogation_direction=light_ray_data.ray_propogation_direction
    ray_source_coordinates=light_ray_data.ray_source_coordinates
    ray_wavelength=light_ray_data.ray_wavelength
    ray_radiance=light_ray_data.ray_radiance
    unique_plane_element_parameters=unique_(element_plane_parameters,char('rows'))
    unique_plane_number=size_(unique_plane_element_parameters,1)
    unique_plane_intersection_time=zeros_(size_(ray_source_coordinates,1),unique_plane_number)
    x_intersect_approximate=zeros_(size_(ray_source_coordinates,1),unique_plane_number)
    y_intersect_approximate=zeros_(size_(ray_source_coordinates,1),unique_plane_number)
    z_intersect_approximate=zeros_(size_(ray_source_coordinates,1),unique_plane_number)
    for plane_parameters_index in arange_(1,unique_plane_number).reshape(-1):
        a=unique_plane_element_parameters[plane_parameters_index,1]
        b=unique_plane_element_parameters[plane_parameters_index,2]
        c=unique_plane_element_parameters[plane_parameters_index,3]
        d=unique_plane_element_parameters[plane_parameters_index,4]
        unique_plane_intersection_time[:,plane_parameters_index]=- (a * ray_source_coordinates[:,1] + b * ray_source_coordinates[:,2] + c * ray_source_coordinates[:,3] + d) / (a * ray_propogation_direction[:,1] + b * ray_propogation_direction[:,2] + c * ray_propogation_direction[:,3])
        x_intersect_approximate[:,plane_parameters_index]=ray_source_coordinates[:,1] + ray_propogation_direction[:,1].dot(unique_plane_intersection_time[plane_parameters_index])
        y_intersect_approximate[:,plane_parameters_index]=ray_source_coordinates[:,2] + ray_propogation_direction[:,2].dot(unique_plane_intersection_time[plane_parameters_index])
        z_intersect_approximate[:,plane_parameters_index]=ray_source_coordinates[:,3] + ray_propogation_direction[:,3].dot(unique_plane_intersection_time[plane_parameters_index])
    __,unique_plane_index_order=sort_(unique_plane_intersection_time,1,char('ascend'),nargout=2)
    light_ray_data_temp=copy_(struct)
    for plane_parameters_index in arange_(1,unique_plane_number).reshape(-1):
        x_intersect_approxiate_current=x_intersect_approximate[:,unique_plane_index_order[plane_parameters_index]]
        y_intersect_approxiate_current=y_intersect_approximate[:,unique_plane_index_order[plane_parameters_index]]
        z_intersect_approxiate_current=z_intersect_approximate[:,unique_plane_index_order[plane_parameters_index]]
        optical_element_indices=find_(all_(bsxfun_(eq,unique_plane_element_parameters[plane_parameters_index,:],element_plane_parameters),2))
        xc_current=element_center[optical_element_indices,1]
        yc_current=element_center[optical_element_indices,2]
        zc_current=element_center[optical_element_indices,3]
        nearest_neighbor_index=knnsearch_([xc_current,yc_current,zc_current],[x_intersect_approxiate_current,y_intersect_approxiate_current,z_intersect_approxiate_current],char('K'),1,char('Distance'),char('euclidean'))
        for element_index in arange_(1,length_(optical_element_indices)).reshape(-1):
            light_ray_indices=(nearest_neighbor_index == element_index)
            light_ray_data_temp.ray_propogation_direction=ray_propogation_direction[light_ray_indices,:]
            light_ray_data_temp.ray_source_coordinates=ray_source_coordinates[light_ray_indices,:]
            light_ray_data_temp.ray_wavelength=ray_wavelength[light_ray_indices]
            light_ray_data_temp.ray_radiance=ray_radiance[light_ray_indices]
            current_optical_element=optical_element[optical_element_indices[element_index]]
            current_plane_parameters=element_plane_parameters[optical_element_indices[element_index],:]
            current_element_center=element_center[optical_element_indices[element_index],:]
            light_ray_data_temp=propogate_rays_through_single_element_(current_optical_element,current_element_center,current_plane_parameters,light_ray_data_temp)
            ray_propogation_direction[light_ray_indices,:]=light_ray_data_temp.ray_propogation_direction
            ray_source_coordinates[light_ray_indices,:]=light_ray_data_temp.ray_source_coordinates
            ray_wavelength[light_ray_indices]=light_ray_data_temp.ray_wavelength
            ray_radiance[light_ray_indices]=light_ray_data_temp.ray_radiance
    light_ray_data.ray_propogation_direction=ray_propogation_direction
    light_ray_data.ray_source_coordinates=ray_source_coordinates
    light_ray_data.ray_wavelength=ray_wavelength
    light_ray_data.ray_radiance=ray_radiance
    return light_ray_data
def propogate_rays_through_single_element_(optical_element=None,element_center=None,element_plane_parameters=None,light_ray_data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[optical_element,element_center,element_plane_parameters,light_ray_data].count(None)+len(args)

    element_type=optical_element.element_type
    ray_propogation_direction=light_ray_data.ray_propogation_direction
    ray_source_coordinates=light_ray_data.ray_source_coordinates
    ray_wavelength=light_ray_data.ray_wavelength
    ray_radiance=light_ray_data.ray_radiance
    if strcmp_(element_type,char('lens')):
        element_pitch=optical_element.element_geometry.pitch
        element_vertex_distance=optical_element.element_geometry.vertex_distance
        element_front_surface_curvature=optical_element.element_geometry.front_surface_radius
        element_back_surface_curvature=optical_element.element_geometry.back_surface_radius
        element_refractive_index=optical_element.element_properties.refractive_index
        element_abbe_number=optical_element.element_properties.abbe_number
        element_transmission_ratio=optical_element.element_properties.transmission_ratio
        element_absorbance_rate=optical_element.element_properties.absorbance_rate
        a=element_plane_parameters[1]
        b=element_plane_parameters[2]
        c=element_plane_parameters[3]
        d=element_plane_parameters[4]
        xc=element_center[1]
        yc=element_center[2]
        zc=element_center[3]
        norm_vector_magnitude=sqrt_(a ** 2 + b ** 2 + c ** 2)
        ds=+ element_vertex_distance / 2 - element_front_surface_curvature
        xc_front_surface=xc + a * ds / norm_vector_magnitude
        yc_front_surface=yc + b * ds / norm_vector_magnitude
        zc_front_surface=zc + c * ds / norm_vector_magnitude
        x_intersect,y_intersect,z_intersect=ray_sphere_intersection_(xc_front_surface,yc_front_surface,zc_front_surface,element_front_surface_curvature,ray_propogation_direction[:,1],ray_propogation_direction[:,2],ray_propogation_direction[:,3],ray_source_coordinates[:,1],ray_source_coordinates[:,2],ray_source_coordinates[:,3],char('front'),nargout=3)
        optical_axis_distance=measure_distance_to_optical_axis_(x_intersect,y_intersect,z_intersect,element_center.T,element_plane_parameters.T)
        intersect_lens_indices=(optical_axis_distance <= (element_pitch / 2))
        ray_propogation_direction[not_(intersect_lens_indices),:]=NaN
        ray_wavelength[not_(intersect_lens_indices)]=NaN
        ray_radiance[not_(intersect_lens_indices)]=NaN
        x_intersect[not_(intersect_lens_indices)]=NaN
        y_intersect[not_(intersect_lens_indices)]=NaN
        z_intersect[not_(intersect_lens_indices)]=NaN
        lens_normal_vectors=+ [x_intersect - xc_front_surface,y_intersect - yc_front_surface,z_intersect - zc_front_surface]
        lens_normal_vectors=bsxfun_(rdivide,lens_normal_vectors,sqrt_(lens_normal_vectors[:,1] ** 2 + lens_normal_vectors[:,2] ** 2 + lens_normal_vectors[:,3] ** 2))
        if not_(ischar_(element_refractive_index)):
            if not_(isempty_(element_abbe_number)):
                lambda_D=589.3
                lambda_F=486.1
                lambda_C=656.3
                refractive_index_ratio=1.0 / (element_refractive_index + (1.0 / (ray_wavelength ** 2) - 1 / (lambda_D ** 2)) * ((element_refractive_index - 1) / (element_abbe_number * (1 / (lambda_F ** 2) - 1 / (lambda_C ** 2)))))
            else:
                refractive_index_ratio=1 / element_refractive_index
        else:
            _lambda=copy_(ray_wavelength)
            eval_([char('element_refractive_index_double='),element_refractive_index,char(';')])
            refractive_index_ratio=1.0 / element_refractive_index_double
        ray_dot_product=- dot_(ray_propogation_direction,lens_normal_vectors,2)
        refraction_radicand=1 - (refractive_index_ratio ** 2).dot((1 - ray_dot_product ** 2))
        ray_propogation_direction=bsxfun_(times,refractive_index_ratio,ray_propogation_direction) + bsxfun_(times,(refractive_index_ratio.dot(ray_dot_product) - sqrt_(refraction_radicand)),lens_normal_vectors)
        ray_propogation_direction=bsxfun_(rdivide,ray_propogation_direction,sqrt_(ray_propogation_direction[:,1] ** 2 + ray_propogation_direction[:,2] ** 2 + ray_propogation_direction[:,3] ** 2))
        ray_source_coordinates=matlabarray([x_intersect,y_intersect,z_intersect])
        tir_indices=(refraction_radicand < 0)
        ray_propogation_direction[tir_indices,:]=NaN
        ray_source_coordinates[tir_indices,:]=NaN
        ray_wavelength[tir_indices]=NaN
        ray_radiance[tir_indices]=NaN
        ds=- element_vertex_distance / 2 - element_back_surface_curvature
        xc_back_surface=xc + a * ds / norm_vector_magnitude
        yc_back_surface=yc + b * ds / norm_vector_magnitude
        zc_back_surface=zc + c * ds / norm_vector_magnitude
        x_intersect,y_intersect,z_intersect=ray_sphere_intersection_(xc_back_surface,yc_back_surface,zc_back_surface,element_back_surface_curvature,ray_propogation_direction[:,1],ray_propogation_direction[:,2],ray_propogation_direction[:,3],ray_source_coordinates[:,1],ray_source_coordinates[:,2],ray_source_coordinates[:,3],char('back'),nargout=3)
        optical_axis_distance=measure_distance_to_optical_axis_(x_intersect,y_intersect,z_intersect,element_center.T,element_plane_parameters.T)
        intersect_lens_indices=(optical_axis_distance <= (element_pitch / 2))
        ray_propogation_direction[not_(intersect_lens_indices),:]=NaN
        ray_source_coordinates[not_(intersect_lens_indices),:]=NaN
        ray_wavelength[not_(intersect_lens_indices)]=NaN
        ray_radiance[not_(intersect_lens_indices)]=NaN
        x_intersect[not_(intersect_lens_indices)]=NaN
        y_intersect[not_(intersect_lens_indices)]=NaN
        z_intersect[not_(intersect_lens_indices)]=NaN
        lens_normal_vectors=- [x_intersect - xc_back_surface,y_intersect - yc_back_surface,z_intersect - zc_back_surface]
        lens_normal_vectors=bsxfun_(rdivide,lens_normal_vectors,sqrt_(lens_normal_vectors[:,1] ** 2 + lens_normal_vectors[:,2] ** 2 + lens_normal_vectors[:,3] ** 2))
        if not_(ischar_(element_refractive_index)):
            if not_(isempty_(element_abbe_number)):
                lambda_D=589.3
                lambda_F=486.1
                lambda_C=656.3
                refractive_index_ratio=element_refractive_index + (1.0 / (ray_wavelength ** 2) - 1 / (lambda_D ** 2)) * ((element_refractive_index - 1) / (element_abbe_number * (1 / (lambda_F ** 2) - 1 / (lambda_C ** 2))))
            else:
                refractive_index_ratio=copy_(element_refractive_index)
        else:
            refractive_index_ratio=copy_(element_refractive_index_double)
        ray_dot_product=- dot_(ray_propogation_direction,lens_normal_vectors,2)
        refraction_radicand=1 - (refractive_index_ratio ** 2).dot((1 - ray_dot_product ** 2))
        ray_propogation_direction=bsxfun_(times,refractive_index_ratio,ray_propogation_direction) + bsxfun_(times,(refractive_index_ratio.dot(ray_dot_product) - sqrt_(refraction_radicand)),lens_normal_vectors)
        ray_propogation_direction=bsxfun_(rdivide,ray_propogation_direction,sqrt_(ray_propogation_direction[:,1] ** 2 + ray_propogation_direction[:,2] ** 2 + ray_propogation_direction[:,3] ** 2))
        if not_(isnan_(element_absorbance_rate)):
            propogation_distance=sqrt_((x_intersect - ray_source_coordinates[:,1]) ** 2 + (y_intersect - ray_source_coordinates[:,2]) ** 2 + (z_intersect - ray_source_coordinates[:,3]) ** 2)
            if not_(ischar_(element_absorbance_rate)):
                ray_radiance=(1 - element_absorbance_rate) * ray_radiance.dot(propogation_distance)
            else:
                x1=ray_source_coordinates[:,1]
                y1=ray_source_coordinates[:,2]
                z1=ray_source_coordinates[:,3]
                x2=copy_(x_intersect)
                y2=copy_(y_intersect)
                z2=copy_(z_intersect)
                xL1,yL1,zL1=convert_world_coordinates_to_lens_coordinates_(x1,y1,z1,xc,yc,zc,a,b,c,nargout=3)
                xL2,yL2,zL2=convert_world_coordinates_to_lens_coordinates_(x2,y2,z2,xc,yc,zc,a,b,c,nargout=3)
                rL1=sqrt_(xL1 ** 2 + yL1 ** 2)
                rL2=sqrt_(xL2 ** 2 + yL2 ** 2)
                x_substitution=char('(xL1+(xL2-xL1)*t)')
                y_substitution=char('(yL1+(yL2-yL1)*t)')
                z_substitution=char('(zL1+(zL2-zL1)*t)')
                r_substitution=char('(rL1+(rL2-rL1)*t)')
                element_absorbance_rate=regexprep_(element_absorbance_rate,char('[x]'),x_substitution)
                element_absorbance_rate=regexprep_(element_absorbance_rate,char('[y]'),y_substitution)
                element_absorbance_rate=regexprep_(element_absorbance_rate,char('[z]'),z_substitution)
                element_absorbance_rate=regexprep_(element_absorbance_rate,char('[r]'),r_substitution)
                eval_([char('absorbance_function_handle=@(t)'),element_absorbance_rate,char(';')])
                element_transmission_ratio=1 - propogation_distance * quad_(absorbance_function_handle,0,1)
                ray_radiance=element_transmission_ratio.dot(ray_radiance)
        else:
            ray_radiance=element_transmission_ratio * ray_radiance
        ray_source_coordinates=matlabarray([x_intersect,y_intersect,z_intersect])
        tir_indices=(refraction_radicand < 0)
        ray_propogation_direction[tir_indices,:]=NaN
        ray_source_coordinates[tir_indices,:]=NaN
        ray_wavelength[tir_indices]=NaN
        ray_radiance[tir_indices]=NaN
    else:
        if strcmp_(element_type,char('aperture')):
            element_pitch=optical_element.element_geometry.pitch
            element_vertex_distance=optical_element.element_geometry.vertex_distance
            a=element_plane_parameters[1]
            b=element_plane_parameters[2]
            c=element_plane_parameters[3]
            d=element_plane_parameters[4]
            norm_vector_magnitude=sqrt_(a ** 2 + b ** 2 + c ** 2)
            ds=- element_vertex_distance / 2
            d_temp=d - ds * norm_vector_magnitude
            intersection_time=- (a * ray_source_coordinates[:,1] + b * ray_source_coordinates[:,2] + c * ray_source_coordinates[:,3] + d_temp) / (a * ray_propogation_direction[:,1] + b * ray_propogation_direction[:,2] + c * ray_propogation_direction[:,3])
            x_intersect=ray_source_coordinates[:,1] + ray_propogation_direction[:,1].dot(intersection_time)
            y_intersect=ray_source_coordinates[:,2] + ray_propogation_direction[:,2].dot(intersection_time)
            z_intersect=ray_source_coordinates[:,3] + ray_propogation_direction[:,3].dot(intersection_time)
            optical_axis_distance=measure_distance_to_optical_axis_(x_intersect,y_intersect,z_intersect,element_center.T,element_plane_parameters.T)
            intersect_aperture_indices=(optical_axis_distance <= (element_pitch / 2))
            ray_propogation_direction[not_(intersect_aperture_indices),:]=NaN
            ray_source_coordinates[not_(intersect_aperture_indices),:]=NaN
            ray_wavelength[not_(intersect_aperture_indices)]=NaN
            ray_radiance[not_(intersect_aperture_indices)]=NaN
            ds=+ element_vertex_distance / 2
            d_temp=d - ds * norm_vector_magnitude
            intersection_time=- (a * ray_source_coordinates[:,1] + b * ray_source_coordinates[:,2] + c * ray_source_coordinates[:,3] + d_temp) / (a * ray_propogation_direction[:,1] + b * ray_propogation_direction[:,2] + c * ray_propogation_direction[:,3])
            x_intersect=ray_source_coordinates[:,1] + ray_propogation_direction[:,1].dot(intersection_time)
            y_intersect=ray_source_coordinates[:,2] + ray_propogation_direction[:,2].dot(intersection_time)
            z_intersect=ray_source_coordinates[:,3] + ray_propogation_direction[:,3].dot(intersection_time)
            optical_axis_distance=measure_distance_to_optical_axis_(x_intersect,y_intersect,z_intersect,element_center.T,element_plane_parameters.T)
            intersect_aperture_indices=(optical_axis_distance <= (element_pitch / 2))
            ray_propogation_direction[not_(intersect_aperture_indices),:]=NaN
            ray_source_coordinates[not_(intersect_aperture_indices),:]=NaN
            ray_wavelength[not_(intersect_aperture_indices)]=NaN
            ray_radiance[not_(intersect_aperture_indices)]=NaN
    light_ray_data.ray_propogation_direction=ray_propogation_direction
    light_ray_data.ray_source_coordinates=ray_source_coordinates
    light_ray_data.ray_wavelength=ray_wavelength
    light_ray_data.ray_radiance=ray_radiance
    return light_ray_data
def ray_sphere_intersection_(xc=None,yc=None,zc=None,R=None,vx=None,vy=None,vz=None,x0=None,y0=None,z0=None,surface=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 11-[xc,yc,zc,R,vx,vy,vz,x0,y0,z0,surface].count(None)+len(args)

    alpha=vx ** 2 + vy ** 2 + vz ** 2
    beta=2 * (vx.dot((x0 - xc)) + vy.dot((y0 - yc)) + vz.dot((z0 - zc)))
    gamma=(x0 - xc) ** 2 + (y0 - yc) ** 2 + (z0 - zc) ** 2 - R ** 2
    square_root_arguments=beta ** 2 - 4 * alpha.dot(gamma)
    intersection_indices=(square_root_arguments[:] >= 0)
    t1=NaN_(size_(alpha))
    t2=NaN_(size_(alpha))
    t1[intersection_indices]=(- beta[intersection_indices] + sqrt_(square_root_arguments[intersection_indices])) / (2 * alpha[intersection_indices])
    t2[intersection_indices]=(- beta[intersection_indices] - sqrt_(square_root_arguments[intersection_indices])) / (2 * alpha[intersection_indices])
    if strcmp_(surface,char('front')):
        if R > 0:
            t=nanmin_(t1,t2)
        else:
            if R <= 0:
                t=nanmax_(t1,t2)
    else:
        if strcmp_(surface,char('back')):
            if R > 0:
                t=nanmin_(t1,t2)
            else:
                if R <= 0:
                    t=nanmax_(t1,t2)
    xi=x0 + vx.dot(t)
    yi=y0 + vy.dot(t)
    zi=z0 + vz.dot(t)
    return xi,yi,zi
def measure_distance_to_optical_axis_(xi=None,yi=None,zi=None,lens_center=None,plane_parameters=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[xi,yi,zi,lens_center,plane_parameters].count(None)+len(args)

    a=plane_parameters[1,:]
    b=plane_parameters[2,:]
    c=plane_parameters[3,:]
    x0=lens_center[1,:]
    y0=lens_center[2,:]
    z0=lens_center[3,:]
    t_minimum=bsxfun_(rdivide,(bsxfun_(times,a,bsxfun_(minus,xi,x0)) + bsxfun_(times,b,bsxfun_(minus,yi,y0)) + bsxfun_(times,c,bsxfun_(minus,zi,z0))),(a ** 2 + b ** 2 + c ** 2))
    x_optical_axis=x0 + a.dot(t_minimum)
    y_optical_axis=y0 + b.dot(t_minimum)
    z_optical_axis=z0 + c.dot(t_minimum)
    optical_axis_distance=sqrt_(bsxfun_(minus,xi,x_optical_axis) ** 2 + bsxfun_(minus,yi,y_optical_axis) ** 2 + bsxfun_(minus,zi,z_optical_axis) ** 2)
    return optical_axis_distance
def convert_world_coordinates_to_lens_coordinates_(x=None,y=None,z=None,xc=None,yc=None,zc=None,a=None,b=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[x,y,z,xc,yc,zc,a,b,c].count(None)+len(args)

    bc_norm_squared=b ** 2 + c ** 2
    abc_norm=sqrt_(a ** 2 + bc_norm_squared)
    bc_norm=sqrt_(bc_norm_squared)
    xL=(x - xc) * (bc_norm / abc_norm) - (y - yc) * ((a * b) / (bc_norm * abc_norm)) - (z - zc) * ((a * c) / (bc_norm * abc_norm))
    yL=(y - yc) * (c / bc_norm) - (z - zc) * (b / bc_norm)
    zL=(x - xc) * (a / abc_norm) + (y - yc) * (b / abc_norm) + (z - zc) * (c / abc_norm)
    return xL,yL,zL
